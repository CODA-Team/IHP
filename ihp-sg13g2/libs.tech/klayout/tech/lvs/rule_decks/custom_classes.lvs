# frozen_string_literal: true

#==========================================================================
# Copyright 2024 IHP PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# SPDX-License-Identifier: Apache-2.0
#==========================================================================

$logger = logger
$unit = dbu

#================================================
# --------------- CUSTOM CLASSES ----------------
#================================================

#=========== CUSTOM READER ===========
# Custom reader for subcircuit models
class CustomReader < RBA::NetlistSpiceReaderDelegate

  # Override parse_element method to handle exceptions gracefully
  def parse_element(line, element)
    super
  rescue StandardError
    case element
    when 'C'
      super("#{line} C=1e-18", element)
    when 'R'
      super("#{line} R=0", element)
    when 'D'
      if line.downcase.include?('diodev')
        super("#{line}", 'Q')
      else
        super("#{line}", element)
      end
    when 'L'
      if line.downcase.include?('inductor3')
        super("#{line} L=0", 'M')
      else
        super("#{line} L=0", element)
      end
    else
      super
    end
  end

  # Override the element method to handle different types of elements
  def element(circuit, ele, name, model, value, nets, params)
    if CUSTOM_READER.include?(ele) && !(ele == 'D' && !model.downcase.include?('diodev'))
      process_device(ele, circuit, name, model, nets, params)
    else
      super
    end
    true
  end
  
  private

  # Process device element
  def process_device(ele, circuit, name, model, nets, params)
    cls = circuit.netlist.device_class_by_name(model)
    cls ||= create_device_class(ele, circuit, model, nets.size)

    device = circuit.create_device(cls, name)
    connect_terminals(ele, device, model, nets)
    map_params(ele, device, model, params)
  end

  # Create or retrieve the device class based on the element type, model name, and number of nets.
  #
  # @param ele [String] The type of element (C, R, Q, L).
  # @param circuit [Circuit] The circuit object to which the device class will be added.
  # @param model [String] The model name of the device class.
  # @param num_nets [Integer] The number of nets the device class should have.
  # @return [RBA::DeviceClass] The created or retrieved device class.
  def create_device_class(ele, circuit, model, num_nets)
    cls = case ele
          when 'C' then create_capacitor(num_nets)
          when 'R' then create_resistor(model, num_nets)
          when 'Q' then create_bjt(model, num_nets)
          when 'L' then DeviceCustomInd.new(model, num_nets-1)
          when 'D' then  RBA::DeviceClassBJT3Transistor.new
          else
            return super
          end

    cls.name = model
    circuit.netlist.add(cls)
    cls
  end

  # Create a capacitor device class.
  def create_capacitor(num_nets)
    if num_nets != 2
      raise ArgumentError, "Capacitor should have 2 nodes, please recheck"
      return nil
    end
    RBA::DeviceClassCapacitor.new
  end

  # Create a resistor device class.
  def create_resistor(model, num_nets)
    if model.downcase.start_with?('res')
      create_custom_dev(model, num_nets)
    elsif num_nets == 2 && model.downcase.include?('tap')
      RBA::DeviceClassDiode.new
    elsif num_nets == 2
      RBA::DeviceClassResistor.new
    elsif num_nets == 3
      RBA::DeviceClassResistorWithBulk.new
    else
      raise ArgumentError, "Resistor should have two or three nodes, please recheck"
    end
  end

  # Create a bjt device class.
  def create_bjt(model, num_nets)
    if model.downcase.include?('pnp')
      RBA::DeviceClassBJT3Transistor.new
    else
      RBA::DeviceClassBJT4Transistor.new
    end
  end

  # Create custom device class.
  def create_custom_dev(model, num_nets)
    if model.downcase.start_with?('res')
      DeviceCustomRes.new(model, num_nets)
    elsif model.downcase.start_with?('npn')
      DeviceCustomBJT.new(model, num_nets-1)
    else
      raise ArgumentError, "Used #{model} device is not supported yet, please recheck"
    end
  end

  # Connect device terminals based on element type, device, model, and nets.
  #
  # @param ele [String] The type of element (C, R, Q).
  # @param device [RBA::Device] The device object to which terminals will be connected.
  # @param model [String] The model name of the device.
  # @param nets [Array<String>] Array of net names to which terminals will be connected.
  def connect_terminals(ele, device, model, nets)
    term_list = terminal_list_for_element(ele, model, nets)

    term_list.each_with_index do |t, index|
      device.connect_terminal(t, nets[index])
    end
  end

  # Determine terminal list based on element type, model, and nets.
  def terminal_list_for_element(ele, model, nets)
    case ele
    when 'Q'
      model.downcase.include?('pnp') ? %w[C B E] : %w[C B E S] 
    when 'C'
      %w[A B]
    when 'R'
      if model.downcase.start_with?('res')
        gen_terminal_names(model, nets.size)
      elsif model.downcase.include?('tap')
        %w[A C]
      else
        nets.size == 3 ? %w[A B W] : %w[A B]
      end
    when 'D'
        %w[C B E]
    when 'L'
      gen_term_names_with_sub(model, nets.size)
    else
      gen_terminal_names(model, nets.size)
    end
  end

  # Generate terminal names based on model and the number of nets.
  def gen_terminal_names(model, size)
    (0...size).map { |i| "#{model}_#{i + 1}" }
  end

  # Generate terminal names based on model and the number of nets.
  def gen_term_names_with_sub(model, size)
    names = (0...size-1).map { |i| "#{model}_#{i + 1}" }
    names << "#{model}_sub" # Add "extra" element
  end

  # Map parameters based on the model type.
  #
  # @param ele [String] The type of element (C, R, Q, L).
  # @param device [RBA::Device] The device object to which parameters will be mapped.
  # @param model [String] The model name of the device.
  # @param params [Hash] Hash containing parameter values.
  def map_params(ele, device, model, params)
    case ele
    when 'Q'
      map_bjt_params(device, model, params)
    when 'C'
      map_capacitor_params(device, params)
    when 'R'
      map_resistor_params(device, model, params)
    when 'D'
      device.set_parameter('NE', params['M'] || 1.0)
    when 'L'
      map_inductor_params(device, params)
    else
      raise ArgumentError, "#{ele} device with model #{model} is not supported, please recheck"
    end
  end

  # Map parameters for a BJT device.
  def map_bjt_params(device, model, params)
    if model.downcase.include?('pnp')
      device.set_parameter('AE', (params['A'] || 0.0)  * (params['M'] || 1.0) * 1e12)
      device.set_parameter('PE', (params['P'] || 0.0)  * (params['M'] || 1.0) * 1e6)
      device.set_parameter('NE', params['M'] || 1.0)
    else
      device.set_parameter('AE', ((params['WE'] || 0.0) * (params['LE'] || 1.0)) * (params['M'] || 1.0) * 1e12)
      device.set_parameter('PE', ((params['WE'] || 0.0) + (params['LE'] || 1.0)) * (params['M'] || 1.0) * 2e6)
      device.set_parameter('NE', params['M'] || 1.0)
    end
  end

  # Map parameters for a capacitor device.
  def map_capacitor_params(device, params)
    device.set_parameter('A', (params['W'] || 0.0) * (params['L'] || 0.0) * (params['M'] || 1.0) * 1e12)
    device.set_parameter('P', ((params['W'] || 0.0) + (params['L'] || 0.0)) * (params['M'] || 1.0) * 2e6)
    device.set_parameter('C', params['C'] || 0.0)
  end

  # Map parameters for a resistor device.
  def map_resistor_params(device, model, params)
    if model.downcase.include?('tap')
      device.set_parameter('A', (params['A'] || 0.0) * (params['M'] || 1.0) * 1e12)
      device.set_parameter('P', (params['P'] || 0.0) * (params['M'] || 1.0) * 1e6)
    elsif model.downcase.start_with?('res')
      device.set_parameter('w', (params['W'] || 0.0) * 1e6)
      device.set_parameter('l', (params['L'] || 0.0) * 1e6)
      device.set_parameter('ps', (params['PS'] || 0.0) * 1e6)
      device.set_parameter('b', params['B'] || 0.0)
    else
      device.set_parameter('W', (params['W'] || 0.0) * (params['PAR'] || 1.0) * 1e6)
      device.set_parameter('L', (params['L'] || 0.0) * (params['M'] || 1.0) * 1e6)
      device.set_parameter('R', (params['R'] || 0.0) * (params['M'] || 1.0) / (params['PAR'] || 1.0))
    end
  end

  # Map parameters for an inductor device.
  def map_inductor_params(device, params)
    device.set_parameter('w', (params['W'] || 0.0) * 1e6)
    device.set_parameter('s', (params['S'] || 0.0) * 1e6)
    device.set_parameter('d', (params['D'] || 0.0) * 1e6)
    device.set_parameter('nr_r', params['NR_R'] || 0.0)
  end
end

#=============== CUSTOM WRITER ===================

# %include globals.lvs

# Custom writer for SPICE netlists
class CustomWriter < RBA::NetlistSpiceWriterDelegate
  # Write device to SPICE format
  # @param device [RBA::Device] The device to be written
  def write_device(device)
    device_class = device.device_class
    str = generate_device_prefix(device, device_class)
    str += generate_device_terminals(device, device_class)
    str += "#{device_class.name} "
    str += generate_device_parameters(device, device_class)
    emit_line(str)
  end

  private

  # Generate device prefix using the global prefix map
  def generate_device_prefix(device, device_class)
    prefix = PREFIX_MAP[device_class.name] || device.id.to_s
    "#{prefix}#{device.expanded_name} "
  end

  # Generate device terminals
  def generate_device_terminals(device, device_class)
    terminals = device_class.terminal_definitions.map do |td|
      net_to_string(device.net_for_terminal(td.id))
    end
    "#{terminals.join(' ')} "
  end

  # Generate device parameters based on device class
  def generate_device_parameters(device, device_class)
    if device_class.name.start_with?('res')
      generate_parameters(device, 'w', 'l', 'b', 'ps')
    elsif device_class.name.start_with?('diodev')
      generate_parameters(device, 'NE')
    elsif device_class.name.start_with?('ind')
      generate_parameters(device, 'w', 's', 'd', 'nr_r')
    else
      generate_default_parameters(device, device_class)
    end
  end

  # Generate parameters with given keys
  def generate_parameters(device, *keys)
    parameters = keys.map { |key| "#{key}=#{device.parameter(key)}" }
    parameters.join(' ')
  end

  # Generate default parameters for the device
  def generate_default_parameters(device, device_class)
    parameters = device_class.parameter_definitions.map do |pd|
      format('%<name>s=%<value>.12g', name: pd.name, value: device.parameter(pd.id))
    end
    parameters.join(' ')
  end
end

#===========================================

# res2 device extractor
class RES2 < RBA::DeviceClassResistor
  def initialize
    super
    enable_parameter('W', true)
    enable_parameter('L', true)
    enable_parameter('R', false)
  end
end

# res3 device class
class RES3 < RBA::DeviceClassResistor
  def initialize
    super
    enable_parameter('R', false)
    enable_parameter('W', true)
    enable_parameter('L', true)
  end
end

# MIMCAP device class
class MIMCap < RBA::DeviceClassCapacitor
  def initialize
    super
    enable_parameter('C', false)
    enable_parameter('A', true)
    enable_parameter('P', true)
  end
end

# MIMCAP device class
class Diode2 < RBA::DeviceClassDiode
  def initialize
    super
    enable_parameter('A', true)
    enable_parameter('P', true)
  end
end

#=============== CUSTOM DEVICE ===================

# %include custom_devices.lvs
